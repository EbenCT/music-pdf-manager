/**
 * MUSIC PDF MANAGER - CONFIGURACI√ìN CORREGIDA
 * Soluci√≥n para problemas de CSP y carga de dependencias
 */

// === CONFIGURACI√ìN DE CSP CORREGIDA ===
const CSP_APPROVED_SOURCES = {
    scripts: [
        'https://cdnjs.cloudflare.com'  // ‚úÖ Permitido por CSP
    ],
    blocked: [
        'https://cdn.jsdelivr.net'      // ‚ùå Bloqueado por CSP
    ]
};

// === CONFIGURACI√ìN DE DEPENDENCIAS ===
const DEPENDENCY_CONFIG = {
    tesseract: {
        // CORREGIDO: Usar cdnjs.cloudflare.com
        mainScript: 'https://cdnjs.cloudflare.com/ajax/libs/tesseract.js/4.1.4/tesseract.min.js',
        workerScript: 'https://cdnjs.cloudflare.com/ajax/libs/tesseract.js/4.1.4/worker.min.js',
        coreScript: 'https://cdnjs.cloudflare.com/ajax/libs/tesseract.js/4.1.4/tesseract-core.wasm.js',
        // IMPORTANTE: NO usar jsdelivr
        blockedSources: [
            'https://cdn.jsdelivr.net/npm/tesseract.js@v4.1.4/dist/worker.min.js'
        ]
    },
    
    pdfjs: {
        main: 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js',
        worker: 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js',
        cmaps: 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/cmaps/'
    }
};

// === VERIFICADOR DE CSP ===
class CSPValidator {
    static validateSource(url) {
        const domain = new URL(url).origin;
        const isAllowed = CSP_APPROVED_SOURCES.scripts.includes(domain);
        const isBlocked = CSP_APPROVED_SOURCES.blocked.includes(domain);
        
        if (isBlocked) {
            console.error(`‚ùå CSP VIOLATION: ${url} est√° bloqueado por Content Security Policy`);
            console.log(`üí° Usar alternativa desde: ${CSP_APPROVED_SOURCES.scripts[0]}`);
            return false;
        }
        
        if (!isAllowed) {
            console.warn(`‚ö†Ô∏è CSP WARNING: ${url} no est√° en la lista de fuentes aprobadas`);
        }
        
        return isAllowed;
    }
    
    static getApprovedAlternative(blockedUrl) {
        // Mapeo de URLs bloqueadas a alternativas aprobadas
        const alternatives = {
            'https://cdn.jsdelivr.net/npm/tesseract.js@v4.1.4/dist/tesseract.min.js': 
                'https://cdnjs.cloudflare.com/ajax/libs/tesseract.js/4.1.4/tesseract.min.js',
            'https://cdn.jsdelivr.net/npm/tesseract.js@v4.1.4/dist/worker.min.js':
                'https://cdnjs.cloudflare.com/ajax/libs/tesseract.js/4.1.4/worker.min.js'
        };
        
        return alternatives[blockedUrl] || null;
    }
}

// === CARGADOR DE DEPENDENCIAS CORREGIDO ===
class DependencyLoader {
    constructor() {
        this.loadedScripts = new Set();
        this.loadingPromises = new Map();
    }
    
    /**
     * ‚úÖ CORREGIDO: Carga script verificando CSP
     */
    async loadScript(url, options = {}) {
        // Verificar CSP
        if (!CSPValidator.validateSource(url)) {
            const alternative = CSPValidator.getApprovedAlternative(url);
            if (alternative) {
                console.log(`üîÑ Usando alternativa aprobada: ${alternative}`);
                url = alternative;
            } else {
                throw new Error(`CSP violation: No hay alternativa aprobada para ${url}`);
            }
        }
        
        // Evitar cargar el mismo script m√∫ltiples veces
        if (this.loadedScripts.has(url)) {
            console.log(`‚úÖ Script ya cargado: ${url}`);
            return;
        }
        
        // Si ya est√° cargando, esperar la promesa existente
        if (this.loadingPromises.has(url)) {
            console.log(`‚è≥ Esperando carga en progreso: ${url}`);
            return this.loadingPromises.get(url);
        }
        
        // Crear nueva promesa de carga
        const loadPromise = this._loadScriptInternal(url, options);
        this.loadingPromises.set(url, loadPromise);
        
        try {
            await loadPromise;
            this.loadedScripts.add(url);
            console.log(`‚úÖ Script cargado exitosamente: ${url}`);
        } catch (error) {
            console.error(`‚ùå Error cargando script: ${url}`, error);
            throw error;
        } finally {
            this.loadingPromises.delete(url);
        }
    }
    
    /**
     * ‚úÖ INTERNO: Carga real del script
     */
    _loadScriptInternal(url, options) {
        return new Promise((resolve, reject) => {
            const script = document.createElement('script');
            script.src = url;
            script.crossOrigin = 'anonymous';
            
            // Aplicar opciones adicionales
            if (options.async !== undefined) script.async = options.async;
            if (options.defer !== undefined) script.defer = options.defer;
            
            script.onload = () => {
                console.log(`üì• Script descargado: ${url}`);
                resolve();
            };
            
            script.onerror = (error) => {
                console.error(`üí• Error descargando script: ${url}`, error);
                reject(new Error(`Failed to load script: ${url}`));
            };
            
            document.head.appendChild(script);
        });
    }
    
    /**
     * ‚úÖ NUEVO: Carga Tesseract con configuraci√≥n corregida
     */
    async loadTesseract() {
        try {
            console.log('ü§ñ Cargando Tesseract.js con configuraci√≥n CSP corregida...');
            
            // Cargar script principal
            await this.loadScript(DEPENDENCY_CONFIG.tesseract.mainScript);
            
            // Verificar que se carg√≥ correctamente
            if (typeof Tesseract === 'undefined') {
                throw new Error('Tesseract.js no se carg√≥ correctamente');
            }
            
            console.log('‚úÖ Tesseract.js cargado correctamente');
            return true;
            
        } catch (error) {
            console.error('‚ùå Error cargando Tesseract.js:', error);
            throw error;
        }
    }
    
    /**
     * ‚úÖ NUEVO: Configurar Tesseract con rutas corregidas
     */
    configureTesseract() {
        if (typeof Tesseract !== 'undefined') {
            // Configurar rutas usando cdnjs.cloudflare.com
            Tesseract.setLogging(true);
            
            // Configuraci√≥n global para workers
            window.TesseractConfig = {
                workerPath: DEPENDENCY_CONFIG.tesseract.workerScript,
                corePath: DEPENDENCY_CONFIG.tesseract.coreScript,
                langPath: 'https://cdnjs.cloudflare.com/ajax/libs/tesseract.js/4.1.4/lang-data'
            };
            
            console.log('‚öôÔ∏è Tesseract configurado con rutas CSP-compatibles');
        }
    }
    
    /**
     * ‚úÖ NUEVO: Carga PDF.js con configuraci√≥n corregida
     */
    async loadPDFJS() {
        try {
            console.log('üìÑ Cargando PDF.js...');
            
            await this.loadScript(DEPENDENCY_CONFIG.pdfjs.main);
            
            if (typeof pdfjsLib === 'undefined') {
                throw new Error('PDF.js no se carg√≥ correctamente');
            }
            
            // Configurar worker
            pdfjsLib.GlobalWorkerOptions.workerSrc = DEPENDENCY_CONFIG.pdfjs.worker;
            
            console.log('‚úÖ PDF.js cargado y configurado');
            return true;
            
        } catch (error) {
            console.error('‚ùå Error cargando PDF.js:', error);
            throw error;
        }
    }
    
    /**
     * ‚úÖ NUEVO: Carga todas las dependencias en orden
     */
    async loadAllDependencies() {
        const dependencies = [
            { name: 'PDF.js', loader: () => this.loadPDFJS() },
            { name: 'Tesseract.js', loader: () => this.loadTesseract() }
        ];
        
        console.log('üì¶ Iniciando carga de dependencias corregidas...');
        
        for (const dep of dependencies) {
            try {
                console.log(`‚è≥ Cargando ${dep.name}...`);
                await dep.loader();
                console.log(`‚úÖ ${dep.name} cargado exitosamente`);
            } catch (error) {
                console.error(`‚ùå Error cargando ${dep.name}:`, error);
                // Continuar con las siguientes dependencias
            }
        }
        
        // Configurar despu√©s de cargar
        this.configureTesseract();
        
        console.log('üì¶ Carga de dependencias completada');
    }
}

// === CONFIGURACI√ìN MEJORADA DEL M√ìDULO ===
const MODULE_CONFIG = {
    musical: {
        // Configuraci√≥n para extracci√≥n de texto
        textExtraction: {
            useOCRFallback: true,
            ocrLanguages: ['eng', 'spa'],
            maxRetries: 3,
            timeoutMs: 30000,
            enableManualInput: true
        },
        
        // Configuraci√≥n para detecci√≥n de acordes
        chordDetection: {
            enableComplexChords: true,
            enableBassNotes: true,
            strictMode: false,
            minimumConfidence: 0.7
        },
        
        // Configuraci√≥n para manejo de errores
        errorHandling: {
            enableRetries: true,
            maxRetries: 2,
            enableFallbacks: true,
            showDetailedErrors: true
        },
        
        // Configuraci√≥n de interfaz
        ui: {
            showProcessingStatus: true,
            enableDebugMode: true,
            animationDuration: 300
        }
    }
};

// === VERIFICADOR DE ESTADO ===
class SystemStatusChecker {
    static async checkDependencies() {
        const status = {
            pdfjs: typeof pdfjsLib !== 'undefined',
            tesseract: typeof Tesseract !== 'undefined',
            driveAPI: window.AppState?.driveAPI != null,
            musicalComponents: {
                chordDetector: typeof ChordDetector !== 'undefined',
                chordTransposer: typeof ChordTransposer !== 'undefined',
                musicalRenderer: typeof MusicalRenderer !== 'undefined'
            }
        };
        
        const allDepsLoaded = status.pdfjs && 
                            status.tesseract && 
                            status.driveAPI &&
                            Object.values(status.musicalComponents).every(loaded => loaded);
        
        console.log('üîç Estado de dependencias:', status);
        console.log(`üìä Sistema completo: ${allDepsLoaded ? '‚úÖ' : '‚ùå'}`);
        
        return { status, allLoaded: allDepsLoaded };
    }
    
    static async initializeWithDependencyCheck() {
        console.log('üöÄ Iniciando verificaci√≥n e inicializaci√≥n del sistema...');
        
        // Cargar dependencias
        const loader = new DependencyLoader();
        await loader.loadAllDependencies();
        
        // Verificar estado
        const { status, allLoaded } = await this.checkDependencies();
        
        if (!allLoaded) {
            console.warn('‚ö†Ô∏è Algunas dependencias no est√°n disponibles');
            const missing = [];
            
            if (!status.pdfjs) missing.push('PDF.js');
            if (!status.tesseract) missing.push('Tesseract.js');
            if (!status.driveAPI) missing.push('Drive API');
            
            Object.entries(status.musicalComponents).forEach(([name, loaded]) => {
                if (!loaded) missing.push(name);
            });
            
            console.error('‚ùå Dependencias faltantes:', missing);
            return { success: false, missing };
        }
        
        console.log('‚úÖ Todas las dependencias est√°n disponibles');
        return { success: true, missing: [] };
    }
}

// === EXPORTAR CONFIGURACI√ìN ===
window.CSPValidator = CSPValidator;
window.DependencyLoader = DependencyLoader;
window.SystemStatusChecker = SystemStatusChecker;
window.MODULE_CONFIG = MODULE_CONFIG;
window.DEPENDENCY_CONFIG = DEPENDENCY_CONFIG;

// === AUTO-INICIALIZACI√ìN ===
document.addEventListener('DOMContentLoaded', async () => {
    console.log('üîß Inicializando configuraci√≥n corregida del sistema...');
    
    try {
        const result = await SystemStatusChecker.initializeWithDependencyCheck();
        
        if (result.success) {
            console.log('üéâ Sistema inicializado correctamente con todas las dependencias');
            
            // Disparar evento personalizado para notificar que el sistema est√° listo
            const event = new CustomEvent('systemReady', {
                detail: { 
                    timestamp: Date.now(),
                    config: MODULE_CONFIG,
                    dependencies: DEPENDENCY_CONFIG
                }
            });
            document.dispatchEvent(event);
            
        } else {
            console.error('üí• Fallo en la inicializaci√≥n:', result.missing);
            
            // Disparar evento de error
            const errorEvent = new CustomEvent('systemError', {
                detail: {
                    error: 'Missing dependencies',
                    missing: result.missing,
                    timestamp: Date.now()
                }
            });
            document.dispatchEvent(errorEvent);
        }
        
    } catch (error) {
        console.error('üí• Error cr√≠tico en la inicializaci√≥n:', error);
    }
});

console.log('‚öôÔ∏è Configuraci√≥n corregida cargada - CSP y dependencias solucionadas');